using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace MemoryPack.Generator;

partial class MemoryPackGenerator
{
    static void Generate(TypeDeclarationSyntax syntax, Compilation compilation, in SourceProductionContext context)
    {
        var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

        var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken);
        if (typeSymbol == null)
        {
            return;
        }

        // verify is partial
        if (!IsPartial(syntax))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MustBePartial, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        // nested is not allowed
        if (IsNested(syntax))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NestedNotAllow, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        var reference = new ReferenceSymbols(compilation);
        var typeMeta = new TypeMeta(typeSymbol, reference);

        // ReportDiagnostic when validate failed.
        if (!typeMeta.Validate(syntax, context))
        {
            return;
        }

        var sw = new StringWriter();

        sw.WriteLine(@"
// <auto-generated/>
#nullable enable
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // This label has not been referenced
#pragma warning disable CS0219 // Variable assigned but never used
#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.
#pragma warning disable CS8601 // Possible null reference assignment
#pragma warning disable CS8604 // Possible null reference argument for parameter

using System;
using MemoryPack;
");

        var ns = typeMeta.Symbol.ContainingNamespace;
        if (!ns.IsGlobalNamespace)
        {
            sw.WriteLine($"namespace {ns};");
        }
        sw.WriteLine();

        // If not exists documentation comment, write debug info
        if (string.IsNullOrWhiteSpace(typeMeta.Symbol.GetDocumentationCommentXml()))
        {
            sw.WriteLine("/// <summary>");
            BuildDebugInfo(sw, typeMeta, true);
            sw.WriteLine("/// </summary>");
        }

        typeMeta.Emit(sw);

        var code = sw.ToString();

        // global::FooBarBaz.MyClass
        var fullType = typeMeta.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");
        context.AddSource($"{fullType}.MemoryPackFormatter.g.cs", code);
    }

    static bool IsPartial(TypeDeclarationSyntax typeDeclaration)
    {
        return typeDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
    }

    static bool IsNested(TypeDeclarationSyntax typeDeclaration)
    {
        return typeDeclaration.Parent is TypeDeclarationSyntax;
    }

    static void BuildDebugInfo(StringWriter sw, TypeMeta type, bool xmlDocument)
    {
        string WithEscape(ISymbol symbol)
        {
            var str = symbol.FullyQualifiedToString();
            if (xmlDocument)
            {
                return str.Replace("<", "&lt;").Replace(">", "&gt;");
            }
            else
            {
                return str;
            }
        }

        if (!xmlDocument)
        {
            sw.WriteLine(WithEscape(type.Symbol));
            sw.WriteLine("---");
        }
        else
        {
            sw.WriteLine("/// <para>MemoryPack Serialize Members</para>");
        }

        foreach (var item in type.Members)
        {
            if (xmlDocument)
            {
                sw.Write("/// <br>");
            }

            if (type.IsUnmanagedType)
            {
                sw.Write("unmanaged ");
            }

            sw.Write(WithEscape(item.MemberType));
            sw.Write(" ");
            sw.Write(item.Name);

            if (xmlDocument)
            {
                sw.WriteLine("</br>");
            }
            else
            {
                sw.WriteLine();
            }
        }
    }
}

public class TypeMeta
{
    DiagnosticDescriptor? ctorInvalid = null;
    readonly ReferenceSymbols reference;

    public INamedTypeSymbol Symbol { get; }
    public string TypeName { get; }
    public MemberMeta[] Members { get; }
    public bool IsValueType { get; set; }
    public bool IsUnmanagedType { get; }
    public bool IsUnion { get; }
    public bool IsRecord { get; }
    public bool IsInterfaceOrAbstract { get; }
    public IMethodSymbol? Constructor { get; }
    public MethodMeta[] OnSerializing { get; }
    public MethodMeta[] OnSerialized { get; }
    public MethodMeta[] OnDeserializing { get; }
    public MethodMeta[] OnDeserialized { get; }
    public (byte Tag, INamedTypeSymbol Type)[] UnionTags { get; }
    public bool IsUseEmptyConstructor => Constructor == null || Constructor.Parameters.IsEmpty;

    public TypeMeta(INamedTypeSymbol symbol, ReferenceSymbols reference)
    {
        this.reference = reference;
        this.Symbol = symbol;
        this.TypeName = symbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        this.Constructor = ChooseConstructor(symbol, reference);

        this.Members = symbol.GetAllMembers() // iterate includes parent type
            .Where(x => x is (IFieldSymbol or IPropertySymbol) and { IsStatic: false, IsImplicitlyDeclared: false })
            .Where(x =>
            {
                var include = x.ContainsAttribute(reference.MemoryPackIncludeAttribute);
                var ignore = x.ContainsAttribute(reference.MemoryPackIgnoreAttribute);
                if (ignore) return false;
                if (include) return true;
                return x.DeclaredAccessibility is Accessibility.Public;
            })
            .Where(x =>
            {
                if (x is IPropertySymbol p)
                {
                    // set only can't be serializable member
                    if (p.GetMethod == null && p.SetMethod != null)
                    {
                        return false;
                    }
                }
                return true;
            })
            .Select(x => new MemberMeta(x, Constructor, reference))
            .ToArray();
        this.IsValueType = symbol.IsValueType;
        this.IsUnmanagedType = symbol.IsUnmanagedType;
        this.IsInterfaceOrAbstract = symbol.IsAbstract;
        this.IsUnion = symbol.ContainsAttribute(reference.MemoryPackUnionAttribute);
        this.IsRecord = symbol.IsRecord;
        this.OnSerializing = CollectMethod(reference.MemoryPackOnSerializingAttribute, IsValueType);
        this.OnSerialized = CollectMethod(reference.MemoryPackOnSerializedAttribute, IsValueType);
        this.OnDeserializing = CollectMethod(reference.MemoryPackOnDeserializingAttribute, IsValueType);
        this.OnDeserialized = CollectMethod(reference.MemoryPackOnDeserializedAttribute, IsValueType);
        if (IsUnion)
        {
            this.UnionTags = symbol.GetAttributes()
                .Where(x => SymbolEqualityComparer.Default.Equals(x.AttributeClass, reference.MemoryPackUnionAttribute))
                .Where(x => x.ConstructorArguments.Length == 2)
                .Select(x => ((byte)x.ConstructorArguments[0].Value!, (INamedTypeSymbol)x.ConstructorArguments[1].Value!))
                .ToArray();
        }
        else
        {
            this.UnionTags = Array.Empty<(byte, INamedTypeSymbol)>();
        }
    }

    // MemoryPack choose class/struct as same rule.
    // If has no explicit constrtucotr, use parameterless one.
    // If has a one parameterless/parameterized constructor, choose it.
    // If has multiple construcotrs, should apply [MemoryPackConstructor] attribute(no automatically choose one), otherwise generator error it.
    IMethodSymbol? ChooseConstructor(ITypeSymbol symbol, ReferenceSymbols reference)
    {
        var ctors = symbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(x => x.MethodKind == MethodKind.Constructor)
            .Where(x => !x.IsImplicitlyDeclared) // remove empty ctor(struct always generate it), record's clone ctor
            .ToArray();

        if (ctors.Length == 0)
        {
            return null; // allows null as ok(not exists explicitly declared constructor == has implictly empty ctor)
        }

        if (ctors.Length == 1)
        {
            return ctors[0];
        }

        var ctorWithAttrs = ctors.Where(x => x.ContainsAttribute(reference.MemoryPackConstructorAttribute)).ToArray();

        if (ctorWithAttrs.Length == 0)
        {
            ctorInvalid = DiagnosticDescriptors.MultipleCtorWithoutAttribute;
            return null;
        }
        else if (ctorWithAttrs.Length == 1)
        {
            return ctorWithAttrs[0]; // ok
        }
        else
        {
            ctorInvalid = DiagnosticDescriptors.MultipleCtorAttribute;
            return null;
        }
    }

    MethodMeta[] CollectMethod(INamedTypeSymbol attribute, bool isValueType)
    {
        return Symbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(x => x.ContainsAttribute(attribute))
            .Select(x => new MethodMeta(x, isValueType))
            .ToArray();
    }

    public bool Validate(TypeDeclarationSyntax syntax, SourceProductionContext context)
    {
        var noError = true;

        // interface/abstract but not union
        if (IsInterfaceOrAbstract && !IsUnion)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.AbstractMustUnion, syntax.Identifier.GetLocation(), Symbol.Name));
            noError = false;
        }

        if (ctorInvalid != null)
        {
            context.ReportDiagnostic(Diagnostic.Create(ctorInvalid, syntax.Identifier.GetLocation(), Symbol.Name));
            noError = false;
        }

        // check ctor members
        if (this.Constructor != null)
        {
            var nameDict = new HashSet<string>(Members.Where(x => x.IsConstructorParameter).Select(x => x.Name), StringComparer.OrdinalIgnoreCase);
            var allParameterExists = this.Constructor.Parameters.All(x => nameDict.Contains(x.Name));
            if (!allParameterExists)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.ConstructorHasNoMatchedParameter, syntax.Identifier.GetLocation(), Symbol.Name));
                noError = false;
            }
        }

        // methods
        foreach (var item in OnSerializing.Concat(OnSerialized).Concat(OnDeserializing).Concat(OnDeserialized))
        {
            if (item.Symbol.Parameters.Length != 0)
            {
                // diagnostics location should be method identifier
                // however methodsymbol -> methodsyntax is slightly hard so use type identifier instead.
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.OnMethodHasParameter, syntax.Identifier.GetLocation(), Symbol.Name, item.Name));
                noError = false;
            }
            if (IsUnmanagedType)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.OnMethodInUnamannagedType, syntax.Identifier.GetLocation(), Symbol.Name, item.Name));
                noError = false;
            }
        }

        // Member override member can't annotate[Ignore][Include]
        if (Symbol.BaseType != null)
        {
            foreach (var item in Symbol.GetAllMembers(withoutOverride: false))
            {
                if (item.IsOverride)
                {
                    var include = item.ContainsAttribute(reference.MemoryPackIncludeAttribute);
                    var ignore = item.ContainsAttribute(reference.MemoryPackIgnoreAttribute);
                    if (include || ignore)
                    {
                        var attr = include ? "MemoryPackInclude" : "MemoryPackIgnore";
                        context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.OverrideMemberCantAddAnnotation, syntax.Identifier.GetLocation(), Symbol.Name, item.Name, attr));
                        noError = false;
                    }
                }
            }
        }

        // ALl Members
        if (Members.Length >= 250) // MemoryPackCode.Reserved1
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MembersCountOver250, syntax.Identifier.GetLocation(), Symbol.Name, Members.Length));
            noError = false;
        }

        // exists can't serialize member
        foreach (var item in Members)
        {
            if (item.Kind == MemberKind.NonSerializable)
            {
                if (item.MemberType.SpecialType is SpecialType.System_Object or SpecialType.System_Array or SpecialType.System_Delegate or SpecialType.System_MulticastDelegate || item.MemberType.TypeKind == TypeKind.Delegate)
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MemberCantSerializeType, syntax.Identifier.GetLocation(), Symbol.Name, item.Name, item.MemberType.FullyQualifiedToString()));
                    noError = false;
                }
                else
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MemberIsNotMemoryPackable, syntax.Identifier.GetLocation(), Symbol.Name, item.Name, item.MemberType.FullyQualifiedToString()));
                    noError = false;
                }
            }
        }

        // Union validations
        if (IsUnion)
        {
            if (Symbol.IsSealed)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.SealedTypeCantBeUnion, syntax.Identifier.GetLocation(), Symbol.Name));
                noError = false;
            }

            if (!Symbol.IsAbstract)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.ConcreteTypeCantBeUnion, syntax.Identifier.GetLocation(), Symbol.Name));
                noError = false;
            }

            if (UnionTags.Select(x => x.Tag).HasDuplicate())
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.UnionTagDuplicate, syntax.Identifier.GetLocation(), Symbol.Name));
                noError = false;
            }

            foreach (var item in UnionTags)
            {
                // type does not derived target symbol
                if (Symbol.TypeKind == TypeKind.Interface)
                {
                    // interface, check interfaces.
                    var check = item.Type.IsGenericType
                        ? item.Type.OriginalDefinition.AllInterfaces.Any(x => x.EqualsUnconstructedGenericType(Symbol))
                        : item.Type.AllInterfaces.Any(x => SymbolEqualityComparer.Default.Equals(x, Symbol));

                    if (!check)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.UnionMemberTypeNotImplementBaseType, syntax.Identifier.GetLocation(), Symbol.Name, item.Type.Name));
                        noError = false;
                    }
                }
                else
                {
                    // abstract type, check base.
                    var check = item.Type.IsGenericType
                        ? item.Type.OriginalDefinition.GetAllBaseTypes().Any(x => x.EqualsUnconstructedGenericType(Symbol))
                        : item.Type.GetAllBaseTypes().Any(x => SymbolEqualityComparer.Default.Equals(x, Symbol));

                    if (!check)
                    {
                        context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.UnionMemberTypeNotDerivedBaseType, syntax.Identifier.GetLocation(), Symbol.Name, item.Type.Name));
                        noError = false;
                    }
                }

                if (item.Type.IsValueType)
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.UnionMemberNotAllowStruct, syntax.Identifier.GetLocation(), Symbol.Name, item.Type.Name));
                    noError = false;
                }

                if (!item.Type.ContainsAttribute(reference.MemoryPackableAttribute))
                {
                    context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.UnionMemberMustBeMemoryPackable, syntax.Identifier.GetLocation(), Symbol.Name, item.Type.Name));
                    noError = false;
                }
            }
        }

        return noError;
    }

    public void Emit(StringWriter writer)
    {
        if (IsUnion)
        {
            writer.WriteLine(EmitUnionTemplate());
            return;
        }

        var serializeBody = "";
        var deserializeBody = "";
        if (IsUnmanagedType)
        {
            serializeBody = $$"""
        writer.WriteUnmanaged(value);
""";
            deserializeBody = $$"""
        reader.ReadUnmanaged(out value);
""";
        }
        else
        {
            serializeBody = EmitSerializeBody();
            deserializeBody = EmitDeserializeBody();
        }

        var classOrStructOrRecord = (IsRecord, IsValueType) switch
        {
            (true, true) => "record struct",
            (true, false) => "record",
            (false, true) => "struct",
            (false, false) => "class",
        };

        var nullable = IsValueType ? "" : "?";

        // TODO:Optimize pattern
        // TODO:regsiter member's generics formatters(e.g. list, dict).

        var code = $$"""
partial {{classOrStructOrRecord}} {{TypeName}} : IMemoryPackable<{{TypeName}}>
{
    static {{Symbol.Name}}()
    {
        MemoryPackFormatterProvider.Register<{{TypeName}}>();
    }

    static void IMemoryPackFormatterRegister.RegisterFormatter()
    {
        if (!MemoryPackFormatterProvider.IsRegistered<{{TypeName}}>())
        {
            MemoryPackFormatterProvider.Register(new MemoryPack.Formatters.MemoryPackableFormatter<{{TypeName}}>());
        }
    }

    static void IMemoryPackable<{{TypeName}}>.Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref {{TypeName}}{{nullable}} value)
    {
{{OnSerializing.Select(x => "        " + x.Emit()).NewLine()}}
{{serializeBody}}
    END:
{{OnSerialized.Select(x => "        " + x.Emit()).NewLine()}}
        return;
    }

    static void IMemoryPackable<{{TypeName}}>.Deserialize(ref MemoryPackReader reader, scoped ref {{TypeName}}{{nullable}} value)
    {
{{OnDeserializing.Select(x => "        " + x.Emit()).NewLine()}}
{{deserializeBody}}
    END:
{{OnDeserialized.Select(x => "        " + x.Emit()).NewLine()}}
        return;
    }
}
""";

        writer.WriteLine(code);
    }

    private string EmitDeserializeBody()
    {
        var count = Members.Length;

        return $$"""
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = default!;
            goto END;
        }
        
{{Members.Select(x => $"        {x.MemberType.FullyQualifiedToString()} __{x.Name};").NewLine()}}

        if (count == {{count}})
        {
            {{(IsValueType ? "" : "if (value == null)")}}
            {
{{EmitDeserializeMembers(Members, "                ")}}

                goto NEW;
            }
{{(IsValueType ? "#if false" : "            else")}}
            {
{{Members.Select(x => $"                __{x.Name} = value.{x.Name};").NewLine()}}

{{Members.Select(x => "                " + x.EmitReadRefDeserialize()).NewLine()}}

                goto SET;
            }
{{(IsValueType ? "#endif" : "")}}
        }
        else if (count > {{count}})
        {
            ThrowHelper.ThrowInvalidPropertyCount({{count}}, count);
            goto END;
        }
        else
        {
            {{(IsValueType ? "" : "if (value == null)")}}
            {
{{Members.Select(x => $"               __{x.Name} = default!;").NewLine()}}
            }
{{(IsValueType ? "#if false" : "            else")}}
            {
{{Members.Select(x => $"               __{x.Name} = value.{x.Name};").NewLine()}}
            }
{{(IsValueType ? "#endif" : "")}}

            if (count == 0) goto SKIP_READ;
{{Members.Select((x, i) => "            " + x.EmitReadRefDeserialize() + $" if (count == {i + 1}) goto SKIP_READ;").NewLine()}}

    SKIP_READ:
            {{(IsValueType ? "" : "if (value == null)")}}
            {
                goto NEW;
            }
{{(IsValueType ? "#if false" : "            else")}}            
            {
                goto SET;
            }
{{(IsValueType ? "#endif" : "")}}
        }

    SET:
        {{(!IsUseEmptyConstructor ? "goto NEW;" : "")}}
{{Members.Where(x => x.IsAssignable).Select(x => $"        {(IsUseEmptyConstructor ? "" : "// ")}value.{x.Name} = __{x.Name};").NewLine()}}
        goto END;

    NEW:
        value = {{EmitConstructor()}}
        {
{{EmitDeserializeConstruction("            ")}}
        };
""";
    }

    string EmitSerializeBody()
    {
        return $$"""
{{(!IsValueType ? $$"""
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            goto END;
        }
""" : "")}}

{{EmitSerializeMembers(Members, "        ")}}
""";
    }

    public string EmitSerializeMembers(MemberMeta[] members, string indent)
    {
        // members is guranteed writable.
        if (members.Length == 0)
        {
            return $"{indent}writer.WriteObjectHeader(0);";
        }

        var sb = new StringBuilder();
        for (int i = 0; i < members.Length; i++)
        {
            if (!members[i].MemberType.IsUnmanagedType)
            {
                sb.Append(indent);
                if (i == 0)
                {
                    sb.AppendLine($"writer.WriteObjectHeader({Members.Length});");
                    sb.Append(indent);
                }

                sb.AppendLine(members[i].EmitSerialize());
                continue;
            }

            // search optimization
            var optimizeFrom = i;
            var optimizeTo = i;
            var limit = Math.Min(members.Length, i + 15);
            for (int j = i; j < limit; j++)
            {
                if (members[j].MemberType.IsUnmanagedType)
                {
                    optimizeTo = j;
                    continue;
                }
                else
                {
                    break;
                }
            }

            // write method
            sb.Append(indent);
            if (optimizeFrom == 0)
            {
                sb.Append("writer.WriteUnmanagedWithObjectHeader(");
                sb.Append(members.Length);
                sb.Append(", ");
            }
            else
            {
                sb.Append("writer.WriteUnmanaged(");
            }

            for (int index = optimizeFrom; index <= optimizeTo; index++)
            {
                if (index != i)
                {
                    sb.Append(", ");
                }
                sb.Append("value.");
                sb.Append(members[index].Name);
            }
            sb.AppendLine(");");

            i = optimizeTo;
        }

        return sb.ToString();
    }

    // for optimize, can use same count, value == null.
    public string EmitDeserializeMembers(MemberMeta[] members, string indent)
    {
        // {{Members.Select(x => "                " + x.EmitReadToDeserialize()).NewLine()}}
        var sb = new StringBuilder();
        for (int i = 0; i < members.Length; i++)
        {
            if (!members[i].MemberType.IsUnmanagedType)
            {
                sb.Append(indent);
                sb.AppendLine(members[i].EmitReadToDeserialize());
                continue;
            }

            // search optimization
            var optimizeFrom = i;
            var optimizeTo = i;
            var limit = Math.Min(members.Length, i + 15);
            for (int j = i; j < limit; j++)
            {
                if (members[j].MemberType.IsUnmanagedType)
                {
                    optimizeTo = j;
                    continue;
                }
                else
                {
                    break;
                }
            }

            // write read method
            sb.Append(indent);
            sb.Append("reader.ReadUnmanaged(");

            for (int index = optimizeFrom; index <= optimizeTo; index++)
            {
                if (index != i)
                {
                    sb.Append(", ");
                }
                sb.Append("out __");
                sb.Append(members[index].Name);
            }
            sb.AppendLine(");");

            i = optimizeTo;
        }

        return sb.ToString();
    }

    string EmitConstructor()
    {
        // noee need `;` because after using object initializer
        if (this.Constructor == null || this.Constructor.Parameters.Length == 0)
        {
            return $"new {TypeName}()";
        }
        else
        {
            var nameDict = Members.ToDictionary(x => x.Name, x => x.Name, StringComparer.OrdinalIgnoreCase);
            var parameters = this.Constructor.Parameters
                .Select(x =>
                {
                    if (nameDict.TryGetValue(x.Name, out var name))
                    {
                        return $"__{name}";
                    }
                    return null; // invalid, validated.
                })
                .Where(x => x != null);

            return $"new {TypeName}({string.Join(", ", parameters)})";
        }
    }

    string EmitDeserializeConstruction(string indent)
    {
        // all value is deserialized, __Name is exsits.
        return string.Join("," + Environment.NewLine, Members
            .Where(x => x.IsSettable && !x.IsConstructorParameter)
            .Select(x => $"{indent}{x.Name} = __{x.Name}"));
    }

    string EmitUnionTemplate()
    {
        var classOrInterface = Symbol.TypeKind == TypeKind.Interface ? "interface" : "class";

        var code = $$"""

partial {{classOrInterface}} {{TypeName}} : IMemoryPackFormatterRegister
{
    static {{Symbol.Name}}()
    {
        MemoryPackFormatterProvider.Register<{{TypeName}}>();
    }

    static void IMemoryPackFormatterRegister.RegisterFormatter()
    {
        if (!MemoryPackFormatterProvider.IsRegistered<{{TypeName}}>())
        {
            MemoryPackFormatterProvider.Register(new {{Symbol.Name}}Formatter());
        }
    }

    sealed class {{Symbol.Name}}Formatter : MemoryPackFormatter<{{TypeName}}>
    {
{{EmitUnionTypeToTagField()}}

        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref {{TypeName}}? value)
        {
{{OnSerializing.Select(x => "            " + x.Emit()).NewLine()}}
{{EmitUnionSerializeBody()}}
{{OnSerialized.Select(x => "            " + x.Emit()).NewLine()}}
        }

        public override void Deserialize(ref MemoryPackReader reader, scoped ref {{TypeName}}? value)
        {
{{OnDeserializing.Select(x => "            " + x.Emit()).NewLine()}}
{{EmitUnionDeserializeBody()}}
{{OnDeserialized.Select(x => "            " + x.Emit()).NewLine()}}            
        }
    }
}
""";

        return code;
    }

    string ToUnionTagTypeFullyQualifiedToString(INamedTypeSymbol type)
    {
        if (type.IsGenericType && this.Symbol.IsGenericType)
        {
            // when generic type, it is unconstructed.( typeof(T<>) ) so construct symbol's T
            var typeName = string.Join(", ", this.Symbol.TypeArguments.Select(x => x.FullyQualifiedToString()));
            return type.FullyQualifiedToString().Replace("<>", "<" + typeName + ">");
        }
        else
        {
            return type.FullyQualifiedToString();
        }
    }


    string EmitUnionTypeToTagField()
    {
        var elements = UnionTags.Select(x => $"            {{ typeof({ToUnionTagTypeFullyQualifiedToString(x.Type)}), {x.Tag} }},").NewLine();

        return $$"""
        static readonly System.Collections.Generic.Dictionary<Type, byte> __typeToTag = new({{UnionTags.Length}})
        {
{{elements}}
        };
""";
    }

    string EmitUnionSerializeBody()
    {
        var writeBody = UnionTags
            .Select(x =>
            {
                var method = x.Type.IsWillImplementIMemoryPackable(reference)
                    ? "WritePackable"
                    : "WriteObject";
                return $"                    case {x.Tag}: writer.{method}(System.Runtime.CompilerServices.Unsafe.As<{TypeName}?, {ToUnionTagTypeFullyQualifiedToString(x.Type)}>(ref value)); break;";
            })
            .NewLine();

        return $$"""
            if (value == null)
            {
                writer.WriteNullObjectHeader();
{{OnSerialized.Select(x => "            " + x.Emit()).NewLine()}}
                return;
            }

            if (__typeToTag.TryGetValue(value.GetType(), out var tag))
            {
                writer.WriteUnionHeader(tag);

                switch (tag)
                {
{{writeBody}}                
                    default:
                        break;
                }
            }
            else
            {
                ThrowHelper.ThrowNotFoundInUnionType(value.GetType(), typeof({{TypeName}}));
            }
""";
    }

    string EmitUnionDeserializeBody()
    {
        var readBody = UnionTags.Select(x =>
        {
            var method = x.Type.IsWillImplementIMemoryPackable(reference)
                ? "ReadPackable"
                : "ReadObject";
            return $$"""
                case {{x.Tag}}:
                    if (value is {{ToUnionTagTypeFullyQualifiedToString(x.Type)}})
                    {
                        reader.{{method}}(ref System.Runtime.CompilerServices.Unsafe.As<{{TypeName}}?, {{ToUnionTagTypeFullyQualifiedToString(x.Type)}}>(ref value));
                    }
                    else
                    {
                        value = reader.{{method}}<{{ToUnionTagTypeFullyQualifiedToString(x.Type)}}>();
                    }
                    break;
""";
        }).NewLine();


        return $$"""
            if (!reader.TryReadUnionHeader(out var tag))
            {
                value = default;
{{OnDeserialized.Select(x => "                " + x.Emit()).NewLine()}}
                return;
            }
        
            switch (tag)
            {
{{readBody}}
                default:
                    ThrowHelper.ThrowInvalidTag(tag, typeof({{TypeName}}));
                    break;
            }
""";
    }
}

public class MethodMeta
{
    public IMethodSymbol Symbol { get; }
    public string Name { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }

    public MethodMeta(IMethodSymbol symbol, bool isValueType)
    {
        this.Symbol = symbol;
        this.Name = symbol.Name;
        this.IsStatic = symbol.IsStatic;
        this.IsValueType = isValueType;
    }

    public string Emit()
    {
        if (IsStatic)
        {
            return $"{Name}();";
        }
        else
        {
            if (IsValueType)
            {
                return $"value.{Name}();";
            }
            else
            {
                return $"value?.{Name}();";
            }
        }
    }
}

public class MemberMeta
{
    public ISymbol Symbol { get; }
    public string Name { get; }
    public ITypeSymbol MemberType { get; }
    public bool IsField { get; }
    public bool IsProperty { get; }
    public bool IsRef { get; }
    public bool IsSettable { get; }
    public bool IsAssignable { get; }
    public bool IsConstructorParameter { get; }
    public MemberKind Kind { get; }

    public MemberMeta(ISymbol symbol, IMethodSymbol? constructor, ReferenceSymbols references)
    {
        this.Symbol = symbol;
        this.Name = symbol.Name;
        this.MemberType = symbol.ContainingType;
        if (constructor != null)
        {
            this.IsConstructorParameter = constructor.Parameters.Any(x => x.Name.Equals(Name, StringComparison.OrdinalIgnoreCase));
        }
        else
        {
            this.IsConstructorParameter = false;
        }

        if (symbol is IFieldSymbol f)
        {
            IsProperty = false;
            IsField = true;
            IsSettable = !f.IsReadOnly; // readonly field can not set.
            IsAssignable = IsSettable && !f.IsRequired;
            IsRef = f.RefKind == RefKind.Ref || f.RefKind == RefKind.RefReadOnly;
            MemberType = f.Type;

        }
        else if (symbol is IPropertySymbol p)
        {
            IsProperty = true;
            IsField = false;
            IsSettable = !p.IsReadOnly;
            IsAssignable = IsSettable && !p.IsRequired && (p.SetMethod != null && !p.SetMethod.IsInitOnly);
            IsRef = p.RefKind == RefKind.Ref || p.RefKind == RefKind.RefReadOnly;
            MemberType = p.Type;
        }
        else
        {
            throw new Exception("member is not field or property.");
        }

        // Setup MemberKind

        if (MemberType.SpecialType is SpecialType.System_Object or SpecialType.System_Array or SpecialType.System_Delegate or SpecialType.System_MulticastDelegate || MemberType.TypeKind == TypeKind.Delegate)
        {
            Kind = MemberKind.NonSerializable; // object, Array, delegate is not allowed
        }
        else if (MemberType.IsUnmanagedType)
        {
            Kind = MemberKind.Unmanaged;
        }
        else if (MemberType.SpecialType == SpecialType.System_String)
        {
            Kind = MemberKind.String;
        }
        else if (MemberType.AllInterfaces.Any(x => x.EqualsUnconstructedGenericType(references.IMemoryPackable)))
        {
            Kind = MemberKind.MemoryPackable;
        }
        else if (MemberType.IsWillImplementIMemoryPackable(references))
        {
            Kind = MemberKind.MemoryPackable;
        }
        //else if (symbol.ContainsAttribute(references.MemoryPackGenerateAttribute))
        //{
        //    Kind = MemberKind.MemoryPackGenerate;
        //}
        else if (symbol.ContainsAttribute(references.MemoryPackFormatterAttribute))
        {
            Kind = MemberKind.MemoryPackFormatter;
        }
        else
        {
            if (MemberType.TypeKind == TypeKind.Array)
            {
                if (MemberType is IArrayTypeSymbol array && array.IsSZArray)
                {
                    var elemType = array.ElementType;
                    if (elemType.IsUnmanagedType)
                    {
                        Kind = MemberKind.UnmanagedArray;
                        return;
                    }
                }

                Kind = MemberKind.Object;
                return;
            }

            if (MemberType.TypeKind == TypeKind.TypeParameter) // T
            {
                Kind = MemberKind.Object;
                return;
            }

            if (references.KnownTypes.Contains(MemberType))
            {
                Kind = MemberKind.KnownType;
                return;
            }

            var isIterable = MemberType.AllInterfaces.Any(x => x.EqualsUnconstructedGenericType(references.KnownTypes.System_Collections_Generic_IEnumerable_T));
            if (isIterable)
            {
                Kind = MemberKind.Object;
            }
            else
            {
                Kind = MemberKind.NonSerializable; // maybe can't serialize, diagnostics target
            }
        }
    }

    public string EmitSerialize()
    {
        switch (Kind)
        {
            case MemberKind.MemoryPackable:
                //case MemberKind.MemoryPackGenerate:
                return $"writer.WritePackable(value.{Name});";
            case MemberKind.Unmanaged:
                return $"writer.WriteUnmanaged(value.{Name});";
            case MemberKind.String:
                return $"writer.WriteString(value.{Name});";
            case MemberKind.UnmanagedArray:
                return $"writer.WriteUnmanagedArray(value.{Name});";
            default:
                return $"writer.WriteObject(value.{Name});";
        }
    }

    public string EmitReadToDeserialize()
    {
        switch (Kind)
        {
            case MemberKind.MemoryPackable:
                return $"__{Name} = reader.ReadPackable<{MemberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
            case MemberKind.Unmanaged:
                return $"reader.ReadUnmanaged(out __{Name});";
            case MemberKind.String:
                return $"__{Name} = reader.ReadString();";
            case MemberKind.UnmanagedArray:
                return $"__{Name} = reader.ReadUnmanagedArray<{(MemberType as IArrayTypeSymbol)!.ElementType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
            default:
                return $"__{Name} = reader.ReadObject<{MemberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
        }
    }

    public string EmitReadRefDeserialize()
    {
        switch (Kind)
        {
            case MemberKind.MemoryPackable:
                return $"reader.ReadPackable(ref __{Name});";
            case MemberKind.Unmanaged:
                return $"reader.ReadUnmanaged(out __{Name});";
            case MemberKind.String:
                return $"__{Name} = reader.ReadString();";
            case MemberKind.UnmanagedArray:
                return $"reader.ReadUnmanagedArray(ref __{Name});";
            default:
                return $"reader.ReadObject(ref __{Name});";
        }
    }
}


public enum MemberKind
{
    MemoryPackable, // IMemoryPackable<> or [MemoryPackable]
    Unmanaged,
    KnownType,
    String,
    UnmanagedArray,

    // from attribute
    // MemoryPackGenerate,
    MemoryPackFormatter,

    Object, // others allow
    NonSerializable // not allowed
}
