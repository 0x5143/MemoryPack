using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MemoryPack.Generator;

partial class MemoryPackGenerator
{
    static void Generate(TypeDeclarationSyntax syntax, Compilation compilation, in SourceProductionContext context)
    {
        var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

        var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken);
        if (typeSymbol == null)
        {
            return;
        }

        // verify is partial
        if (!IsPartial(syntax))
        {
            // TODO:report this
            //context.ReportDiagnostic(Diagnostic.Create(MustBePartial, syntax.GetLocation(), typeSymbol.Name));
            //return;
        }

        var meta = new TypeMeta(typeSymbol, compilation);

        var sw = new StringWriter();

        //"// <auto-generated/>",
        //    "#nullable enable",
        //    "#pragma warning disable CS0162 // Unreachable code",
        //    "#pragma warning disable CS0164 // Unreferenced label",
        //    "#pragma warning disable CS0219 // Variable assigned but never used",




        meta.Emit(sw);


        var code = sw.ToString();



        // context.AddSource($"{typeName}.MemoryPackFormatter.g.cs", code);
    }



    static bool IsPartial(TypeDeclarationSyntax typeDeclaration)
    {
        return typeDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
    }
}




internal static class StringWriterExtensions
{
    public static void WriteIndent(this StringWriter writer)
    {
        writer.Write("        ");
    }
}

internal static class EnumerableExtensions
{
    public static string NewLine(this IEnumerable<string> source)
    {
        return string.Join(Environment.NewLine, source);
    }
}


public class TypeMeta
{
    public INamedTypeSymbol Symbol { get; }
    public string Name { get; }
    public MemberMeta[] Members { get; }
    public bool AllowPrivate { get; }
    public bool IsValueType { get; set; }
    public bool IsUnmanagedType { get; }
    public bool IsUnion { get; }
    public bool IsRecord { get; }
    public bool IsInterfaceOrAbstract { get; }
    public IMethodSymbol? Consrtuctor { get; }
    public MethodMeta[] OnSerializing { get; }
    public MethodMeta[] OnSerialized { get; }
    public MethodMeta[] OnDeserializing { get; }
    public MethodMeta[] OnDeserialized { get; }

    public TypeMeta(INamedTypeSymbol symbol, Compilation compilation)
    {
        this.Symbol = symbol;
        this.Name = symbol.Name;
        this.Members = symbol.GetMembers().Where(x => x is IFieldSymbol or IPropertySymbol).Select(x => new MemberMeta(x)).ToArray(); // TODO:GetMembers?TYpeMembers?CHeckOrder?
        this.IsValueType = symbol.IsValueType;
        this.IsUnmanagedType = symbol.IsUnmanagedType;
        this.IsInterfaceOrAbstract = symbol.IsAbstract; // TODO:IsInterface?
        this.IsRecord = symbol.IsRecord;

        var packableAttribute = compilation.GetTypeByMetadataName(MemoryPackGenerator.MemoryPackableAttributeFullName);
        var attr = symbol.GetAttributes().First(x => SymbolEqualityComparer.Default.Equals(x.AttributeClass, packableAttribute));
        this.AllowPrivate = false;
        if (attr.ConstructorArguments.Length != 0)
        {
            this.AllowPrivate = (bool)attr.ConstructorArguments[0].Value!;
        }

        this.Consrtuctor = null; // TODO:choose best-match constructor
        this.OnSerializing = Array.Empty<MethodMeta>(); // TODO:get methods
        this.OnSerialized = Array.Empty<MethodMeta>(); // TODO:get methods
        this.OnDeserializing = Array.Empty<MethodMeta>(); // TODO:get methods
        this.OnDeserialized = Array.Empty<MethodMeta>(); // TODO:get methods
    }

    public void Emit(StringWriter writer)
    {

        var classOrStructOrRecord = (IsRecord, IsValueType) switch
        {
            (true, true) => "record struct",
            (true, false) => "record",
            (false, true) => "struct",
            (false, false) => "class",
        };

        var nullable = IsValueType ? "" : "?";

        // TODO:Optimize pattern


        var code = $$"""
partial {{classOrStructOrRecord}} {{Name}} : IMemoryPackable<{{Name}}>
{
    static void IMemoryPackable<{{Name}}>.Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref {{Name}}{{nullable}} value)
    {
{{OnSerializing.Select(x => "        " + x.Emit()).NewLine()}}

{{(!IsValueType ? $$"""
        if (value == null)
        {
            writer.WriteNullObjectHeader();
            return;
        }
""" : "")}}

        writer.WriteObjectHeader({{Members.Length}});
{{Members.Select(x => "        " + x.EmitSerialize()).NewLine()}}

{{OnSerialized.Select(x => "        " + x.Emit()).NewLine()}}
    }

    static void IMemoryPackable<{{Name}}>.Deserialize(ref MemoryPackReader reader, scoped ref {{Name}}{{nullable}} value)
    {
        throw new NotImplementedException();
    }

    // TODO: formatter
}


""";

        writer.WriteLine(code);
    }
}


public class MethodMeta
{
    public IMethodSymbol Symbol { get; }
    public string Name { get; }
    public bool IsStatic { get; }

    public MethodMeta(IMethodSymbol symbol)
    {
        this.Symbol = symbol;
        this.Name = symbol.Name;
        this.IsStatic = symbol.IsStatic;
    }

    public string Emit()
    {
        if (IsStatic)
        {
            return $"{Name}();";
        }
        else
        {
            return $"value.{Name}();";
        }
    }
}

public class MemberMeta
{
    public ISymbol Symbol { get; }
    public string Name { get; }
    public bool IsField { get; }
    public bool IsProperty { get; }
    public bool IsRef { get; }
    public MemberKind Kind { get; }

    public MemberMeta(ISymbol symbol)
    {
        this.Symbol = symbol;
        this.Name = symbol.Name;

        if (symbol.Kind == SymbolKind.Property)
        {
            IsProperty = true;
            IsField = false;
        }
        else
        {
            IsProperty = false;
            IsField = true;
        }

        if (symbol is IFieldSymbol f)
        {

        }
        else if (symbol is IPropertySymbol)
        {

        }

        IsRef = false; // TODO:check ref
        Kind = MemberKind.Unmanaged; // TODO:????
    }

    public string EmitSerialize()
    {
        switch (Kind)
        {
            case MemberKind.MemoryPackable:
                return $"writer.WritePackable(ref value.{Name});";
            case MemberKind.Unmanaged:
                return $"writer.WriteUnmanaged(value.{Name});";
            case MemberKind.String:
                return $"writer.WriteString(value.{Name});";
            case MemberKind.KnownType:
            case MemberKind.NoMarked:
                return $"writer.WriteObject(ref value.{Name});";
            case MemberKind.Collection:
                // TODO: inline.
                break;
            default:
                break;
        }

        throw new NotImplementedException();
    }

}


public enum MemberKind
{
    MemoryPackable,
    Unmanaged,
    KnownType,
    String,
    Collection,
    NoMarked
}
