using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Reflection;

namespace MemoryPack.Generator;

partial class MemoryPackGenerator
{
    static void Generate(TypeDeclarationSyntax syntax, Compilation compilation, in SourceProductionContext context)
    {
        var semanticModel = compilation.GetSemanticModel(syntax.SyntaxTree);

        var typeSymbol = semanticModel.GetDeclaredSymbol(syntax, context.CancellationToken);
        if (typeSymbol == null)
        {
            return;
        }

        // verify is partial
        if (!IsPartial(syntax))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.MustBePartial, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        // nested is not allowed
        if (IsNested(syntax))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.NestedNotAllow, syntax.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        var reference = new ReferenceSymbols(compilation);
        var typeMeta = new TypeMeta(typeSymbol, reference);

        // ReportDiagnostic when validate failed.
        if (!typeMeta.Validate(syntax, context))
        {
            return;
        }

        var sw = new StringWriter();

        sw.WriteLine(@"
// <auto-generated/>
#nullable enable
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // Unreferenced label
#pragma warning disable CS0219 // Variable assigned but never used
#pragma warning disable CS8601 // Possible null reference assignment

using System;
using MemoryPack;
");

        var ns = typeMeta.Symbol.ContainingNamespace;
        if (!ns.IsGlobalNamespace)
        {
            sw.WriteLine($"namespace {ns};");
        }

        typeMeta.Emit(sw);

        var code = sw.ToString();

        // global::FooBarBaz.MyClass
        var fullType = typeMeta.Symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "");
        context.AddSource($"{fullType}.MemoryPackFormatter.g.cs", code);
    }

    static bool IsPartial(TypeDeclarationSyntax typeDeclaration)
    {
        return typeDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword));
    }

    static bool IsNested(TypeDeclarationSyntax typeDeclaration)
    {
        return typeDeclaration.Parent is TypeDeclarationSyntax;
    }
}

public class TypeMeta
{
    DiagnosticDescriptor? ctorInvalid = null;

    public INamedTypeSymbol Symbol { get; }
    public string Name { get; }
    public MemberMeta[] Members { get; }
    public bool IsValueType { get; set; }
    public bool IsUnmanagedType { get; }
    public bool IsUnion { get; }
    public bool IsRecord { get; }
    public bool IsInterfaceOrAbstract { get; }
    public IMethodSymbol? Consrtuctor { get; }
    public MethodMeta[] OnSerializing { get; }
    public MethodMeta[] OnSerialized { get; }
    public MethodMeta[] OnDeserializing { get; }
    public MethodMeta[] OnDeserialized { get; }

    public TypeMeta(INamedTypeSymbol symbol, ReferenceSymbols reference)
    {
        this.Symbol = symbol;
        this.Name = symbol.Name;
        this.Consrtuctor = ChooseConstructor(symbol, reference);
        this.Members = symbol.GetMembers()
            .Where(x => x is (IFieldSymbol or IPropertySymbol) and { IsStatic: false, IsImplicitlyDeclared: false })
            .Where(x =>
            {
                var include = x.ContainsAttribute(reference.MemoryPackIncludeAttribute);
                var ignore = x.ContainsAttribute(reference.MemoryPackIgnoreAttribute);
                if (ignore) return false;
                if (include) return true;
                return x.DeclaredAccessibility is Accessibility.Public;
            })
            .Select(x => new MemberMeta(x, Consrtuctor, reference))
            .ToArray();
        this.IsValueType = symbol.IsValueType;
        this.IsUnmanagedType = symbol.IsUnmanagedType;
        this.IsInterfaceOrAbstract = symbol.IsAbstract;
        this.IsUnion = symbol.ContainsAttribute(reference.MemoryPackUnionAttribute);
        this.IsRecord = symbol.IsRecord;
        this.OnSerializing = CollectMethod(reference.MemoryPackOnSerializingAttribute, IsValueType);
        this.OnSerialized = CollectMethod(reference.MemoryPackOnSerializedAttribute, IsValueType);
        this.OnDeserializing = CollectMethod(reference.MemoryPackOnDeserializingAttribute, IsValueType);
        this.OnDeserialized = CollectMethod(reference.MemoryPackOnDeserializedAttribute, IsValueType);
    }

    // MemoryPack choose class/struct as same rule.
    // If has no explicit constrtucotr, use parameterless one.
    // If has a one parameterless/parameterized constructor, choose it.
    // If has multiple construcotrs, should apply [MemoryPackConstructor] attribute(no automatically choose one), otherwise generator error it.
    IMethodSymbol? ChooseConstructor(ITypeSymbol symbol, ReferenceSymbols reference)
    {
        var ctors = symbol.GetMembers().OfType<IMethodSymbol>().Where(x => x.MethodKind == MethodKind.Constructor).ToArray();
        if (ctors.Length == 0)
        {
            return null;
        }

        if (ctors.Length == 1)
        {
            return ctors[0];
        }

        var ctorWithAttrs = ctors.Where(x => x.ContainsAttribute(reference.MemoryPackConstructorAttribute)).ToArray();

        if (ctorWithAttrs.Length == 0)
        {
            ctorInvalid = DiagnosticDescriptors.MultipleCtorWithoutAttribute;
            return null;
        }
        else if (ctorWithAttrs.Length == 1)
        {
            return ctorWithAttrs[0]; // ok
        }
        else
        {
            ctorInvalid = DiagnosticDescriptors.MultipleCtorAttribute;
            return null;
        }
    }

    MethodMeta[] CollectMethod(INamedTypeSymbol attribute, bool isValueType)
    {
        return Symbol.GetMembers()
            .OfType<IMethodSymbol>()
            .Where(x => x.ContainsAttribute(attribute))
            .Select(x => new MethodMeta(x, isValueType))
            .ToArray();
    }

    public bool Validate(TypeDeclarationSyntax syntax, SourceProductionContext context)
    {
        var noError = true;
        // interface/abstract but not union
        if (IsInterfaceOrAbstract && !IsUnion)
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.AbstractMustUnion, syntax.Identifier.GetLocation(), Symbol.Name));
            noError = false;
        }

        if (ctorInvalid != null)
        {
            context.ReportDiagnostic(Diagnostic.Create(ctorInvalid, syntax.Identifier.GetLocation(), Symbol.Name));
            noError = false;
        }

        // check ctor members
        if (this.Consrtuctor != null)
        {
            var nameDict = new HashSet<string>(Members.Where(x => x.IsConstructorParameter).Select(x => x.Name), StringComparer.OrdinalIgnoreCase);
            var allParameterExists = this.Consrtuctor.Parameters.All(x => nameDict.Contains(x.Name));
            if (!allParameterExists)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.ConstructorHasNoMatchedParameter, syntax.Identifier.GetLocation(), Symbol.Name));
                noError = false;
            }
        }

        foreach (var item in OnSerializing.Concat(OnSerialized).Concat(OnDeserializing).Concat(OnDeserialized))
        {
            if (item.Symbol.Parameters.Length != 0)
            {
                // diagnostics location should be method identifier
                // however methodsymbol -> methodsyntax is slightly hard so use type identifier instead.
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.OnMethodHasParameter, syntax.Identifier.GetLocation(), Symbol.Name, item.Name));
                noError = false;
            }
            if (IsUnmanagedType)
            {
                context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.OnMethodInUnamannagedType, syntax.Identifier.GetLocation(), Symbol.Name, item.Name));
                noError = false;
            }
        }

        return noError;
    }

    public void Emit(StringWriter writer)
    {
        var serializeBody = "";
        var deserializeBody = "";
        if (IsUnmanagedType)
        {
            serializeBody = $$"""
        writer.WriteUnmanaged(value);
""";
            deserializeBody = $$"""
        reader.ReadUnmanaged(out value);
""";
        }
        else
        {
            serializeBody = $$"""
{{(!IsValueType ? $$"""
        if (value == null)
        {
            writer.WriteNullObjectHeader();
{{OnSerialized.Select(x => "            " + x.Emit()).NewLine()}}
            return;
        }
""" : "")}}

        writer.WriteObjectHeader({{Members.Length}});
{{Members.Select(x => "        " + x.EmitSerialize()).NewLine()}}
""";
            // TODO: versioning check for count...
            deserializeBody = $$"""
        if (!reader.TryReadObjectHeader(out var count))
        {
            value = default;
{{OnDeserialized.Select(x => "            " + x.Emit()).NewLine()}}
            return;
        }
        
        if (count != {{Members.Length}}) ThrowHelper.ThrowInvalidPropertyCount({{Members.Length}}, count);

{{Members.Select(x => "        " + x.EmitDeserialize()).NewLine()}}
""";
        }

        var classOrStructOrRecord = (IsRecord, IsValueType) switch
        {
            (true, true) => "record struct",
            (true, false) => "record",
            (false, true) => "struct",
            (false, false) => "class",
        };

        var nullable = IsValueType ? "" : "?";

        // TODO:Optimize pattern
        // TODO:register self array formatter(Unamanged or Array Formatter)
        // TODO:regsiter member's generics formatters(e.g. list, dict).
        // TODO:ctor

        var code = $$"""

partial {{classOrStructOrRecord}} {{Name}} : IMemoryPackable<{{Name}}>
{
    static {{Name}}()
    {
        MemoryPackFormatterProvider.Register<{{Name}}>();
    }

    static void IMemoryPackable.RegisterFormatter()
    {
        if (!MemoryPackFormatterProvider.IsRegistered<{{Name}}>())
        {
            MemoryPackFormatterProvider.Register(new {{Name}}Formatter());
        }
    }

    static void IMemoryPackable<{{Name}}>.Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref {{Name}}{{nullable}} value)
    {
{{OnSerializing.Select(x => "        " + x.Emit()).NewLine()}}
{{serializeBody}}
{{OnSerialized.Select(x => "        " + x.Emit()).NewLine()}}
    }

    static void IMemoryPackable<{{Name}}>.Deserialize(ref MemoryPackReader reader, scoped ref {{Name}}{{nullable}} value)
    {
{{OnDeserializing.Select(x => "        " + x.Emit()).NewLine()}}
{{deserializeBody}}
        {{(!IsUnmanagedType ? "value = " + EmitConstructor() : "")}}
{{(!IsUnmanagedType ? EmitDeserializeConstruction() : "")}}
{{OnDeserialized.Select(x => "        " + x.Emit()).NewLine()}}
    }

    sealed class {{Name}}Formatter : MemoryPackFormatter<{{Name}}>
    {
        public override void Serialize<TBufferWriter>(ref MemoryPackWriter<TBufferWriter> writer, scoped ref {{Name}}{{nullable}} value)
        {
            writer.WritePackable(value);
        }

        public override void Deserialize(ref MemoryPackReader reader, scoped ref {{Name}}{{nullable}} value)
        {
            reader.ReadPackable(ref value);
        }
    }
}
""";

        writer.WriteLine(code);
    }

    string EmitConstructor()
    {
        // noee need `;` because after using object initializer
        if (this.Consrtuctor == null || this.Consrtuctor.Parameters.Length == 0)
        {
            return $"new {Name}()";
        }
        else
        {
            var nameDict = Members.ToDictionary(x => x.Name, x => x.Name, StringComparer.OrdinalIgnoreCase);
            var parameters = this.Consrtuctor.Parameters
                .Select(x =>
                {
                    if (nameDict.TryGetValue(x.Name, out var name))
                    {
                        return $"__{name}";
                    }
                    return null; // invalid, validated.
                })
                .Where(x => x != null);

            return $"new {Name}({string.Join(", ", parameters)})";
        }
    }

    string EmitDeserializeConstruction()
    {
        // all value is deserialized, __Name is exsits.
        return $$"""
        {
{{string.Join("," + Environment.NewLine, Members.Where(x => x.IsSettable && !x.IsConstructorParameter).Select(x => "            " + x.EmitConstruction()))}}
        };
""";
    }
}
public class MethodMeta
{
    public IMethodSymbol Symbol { get; }
    public string Name { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }

    public MethodMeta(IMethodSymbol symbol, bool isValueType)
    {
        this.Symbol = symbol;
        this.Name = symbol.Name;
        this.IsStatic = symbol.IsStatic;
        this.IsValueType = isValueType;
    }

    public string Emit()
    {
        if (IsStatic)
        {
            return $"{Name}();";
        }
        else
        {
            if (IsValueType)
            {
                return $"value.{Name}();";
            }
            else
            {
                return $"value?.{Name}();";
            }
        }
    }
}

public class MemberMeta
{
    public ISymbol Symbol { get; }
    public string Name { get; }
    public ITypeSymbol MemberType { get; }
    public bool IsField { get; }
    public bool IsProperty { get; }
    public bool IsRef { get; }
    public bool IsSettable { get; }
    public bool IsConstructorParameter { get; }
    public MemberKind Kind { get; }

    public MemberMeta(ISymbol symbol, IMethodSymbol? constructor, ReferenceSymbols references)
    {
        this.Symbol = symbol;
        this.Name = symbol.Name;
        this.MemberType = symbol.ContainingType;
        if (constructor != null)
        {
            this.IsConstructorParameter = constructor.Parameters.Any(x => x.Name.Equals(Name, StringComparison.OrdinalIgnoreCase));
        }
        else
        {
            this.IsConstructorParameter = false;
        }

        if (symbol is IFieldSymbol f)
        {
            IsProperty = false;
            IsField = true;
            IsSettable = !f.IsReadOnly; // readonly field can not set.
            IsRef = f.RefKind == RefKind.Ref || f.RefKind == RefKind.RefReadOnly;
            MemberType = f.Type;

        }
        else if (symbol is IPropertySymbol p)
        {
            IsProperty = true;
            IsField = false;
            IsSettable = !p.IsReadOnly;
            IsRef = p.RefKind == RefKind.Ref || p.RefKind == RefKind.RefReadOnly;
            MemberType = p.Type;
        }
        else
        {
            throw new Exception("member is not field or property.");
        }

        if (MemberType.IsUnmanagedType)
        {
            Kind = MemberKind.Unmanaged;
        }
        else if (MemberType.SpecialType == SpecialType.System_String)
        {
            Kind = MemberKind.String;
        }
        else if (MemberType.AllInterfaces.Any(x => x.IsGenericType && SymbolEqualityComparer.Default.Equals(x.ConstructUnboundGenericType(), references.IMemoryPackable)))
        {
            Kind = MemberKind.MemoryPackable;
        }
        else
        {
            // TODO: check Collection / KnownType / NonSerializable
            Kind = MemberKind.KnownType; // TODO:????
        }
    }

    public string EmitSerialize()
    {
        switch (Kind)
        {
            case MemberKind.MemoryPackable:
                return $"writer.WritePackable(value.{Name});";
            case MemberKind.Unmanaged:
                return $"writer.WriteUnmanaged(value.{Name});";
            case MemberKind.String:
                return $"writer.WriteString(value.{Name});";
            case MemberKind.KnownType:
            case MemberKind.Collection: // TODO: inline optimization.
            case MemberKind.NonSerializable:
            default:
                return $"writer.WriteObject(value.{Name});";
        }
    }

    public string EmitDeserialize()
    {
        // TODO: MemberTypeName should be full qualified.
        // TODO: pass ref...?
        switch (Kind)
        {
            case MemberKind.MemoryPackable:
                return $"var __{Name} = reader.ReadPackable<{MemberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
            case MemberKind.Unmanaged:
                return $"reader.ReadUnmanaged<{MemberType.Name}>(out var __{Name});";
            case MemberKind.String:
                return $"var __{Name} = reader.ReadString();";
            case MemberKind.KnownType:
            case MemberKind.Collection: // TODO: inline optimization.
            case MemberKind.NonSerializable:
            default:
                return $"var __{Name} = reader.ReadObject<{MemberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}>();";
        }
    }

    public string EmitConstruction()
    {
        // TODO:if consructor parameter, don't emit.
        return $"{Name} = __{Name}";
    }
}


public enum MemberKind
{
    MemoryPackable,
    Unmanaged,
    KnownType,
    String,
    Collection, // TODO: +Array?
    NonSerializable
}
